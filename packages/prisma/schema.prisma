// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider      = "prisma-client-js"
    binaryTargets = ["native"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

generator zod {
    provider      = "zod-prisma"
    output        = "./zod"
    relationModel = "default"
}

enum Gender {
    MALE
    FEMALE
    OTHER
}

enum PostType {
    PUBLIC
    GROUP_ONLY
}

enum PostStatus {
    OPEN
    CLOSED
    ARCHIVED
    INPROGRESS
}

enum FriendType {
    FRIENDS
    PENDING_USER_TO_FRIEND_REQUEST
    PENDING_FRIEND_TO_USER_REQUEST
}

enum GroupType {
    PUBLIC
    PRIVATE
}

enum GroupStatus {
    OPEN
    CLOSED
    INACTIVE
}

enum GroupMemberRole {
    ADMIN
    MODERATOR
    MEMBER
}

enum GroupInvitationType {
    JOIN
    INVITE
}

enum NotificationType {
    PUBLIC_POST_UPVOTE
    GROUP_POST_UPVOTE
    PUBLIC_POST_COMMENT_UPVOTE
    GROUP_POST_COMMENT_UPVOTE
    PUBLIC_POST_COMMENT
    GROUP_POST_COMMENT
    START_FOLLOWING
    FRIEND_REQUEST
    FRIEND_REQUEST_ACCEPTED
    GROUP_INVITATION
    GROUP_INVITATION_ACCEPTED
    JOIN_GROUP_REQUEST
}

enum FactorType {
    TOTP
    PHONE
    WEB_AUTHN
}

enum FactorStatus {
    UNVERIFIED
    VERIFIED
}

model User {
    id                    String    @id @default(cuid())
    email                 String    @unique
    user_name             String    @unique
    password              String
    first_name            String
    last_name             String
    secret                String    @default(uuid()) // Encrypted secret to sign JWT
    about                 String?
    twitter_profile_url   String?
    facebook_profile_url  String?
    instagram_profile_url String?
    github_profile_url    String?
    avatar_url            String?
    cover_image_url       String?
    location              String?
    gender                Gender?
    last_login            DateTime?

    is_onboarded               Boolean   @default(false)
    is_email_verify            Boolean   @default(false)
    email_confirmed_at         DateTime?
    email_confirmation_sent_at DateTime?
    banned_until               DateTime?

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    posts            Post[]
    upvotes          Upvote[]
    comments         Comment[]
    commentUpvotes   CommentUpvote[]
    followers        Follow[]          @relation("followers")
    following        Follow[]          @relation("following")
    friend1          Friend[]          @relation("user")
    friend2          Friend[]          @relation("friend")
    groupMembers     GroupMember[]
    groupInvitations GroupInvitation[]
    notification     Notification[]
    factors          Factor[]
    sessions         Session[]
    refreshTokens    RefreshToken[]
    interests        UserInterests[]
    timelines        Timeline[]
}

model Factor {
    id                 String       @id @default(uuid())
    friendly_name      String
    factor_type        FactorType
    status             FactorStatus
    secret             String // Encrypted secret for TOTP
    phone              String? // For phone-based factors
    last_challenged_at DateTime?

    user_id String
    user    User   @relation(fields: [user_id], references: [id])

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    sessions   Session[] // Sessions authenticated using this factor
    challanges Challange[] // Challanges for this factor

    @@index([user_id], name: "user_id_index")
}

model Challange {
    id       String  @id @default(uuid())
    ip       String
    otp_code String?

    factor_id String
    factor    Factor @relation(fields: [factor_id], references: [id])

    created_at  DateTime  @default(now())
    verified_at DateTime?
}

model Session {
    id         String @id @default(uuid())
    aal        String @default("aal1") // Authentication Assurance Level
    ip         String
    user_agent String

    user_id   String
    user      User    @relation(fields: [user_id], references: [id])
    factor_id String? // Optional if the session requires a factor
    factor    Factor? @relation(fields: [factor_id], references: [id])

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    @@index([user_id], name: "user_session_id_index")
}

model Post {
    id      String     @id @default(cuid())
    title   String     @db.VarChar(255)
    content String     @db.Text
    slug    String     @unique @db.VarChar(255)
    type    PostType   @default(PUBLIC)
    status  PostStatus @default(OPEN)

    group_id String?
    group    Group?  @relation(fields: [group_id], references: [id])

    author_id String
    author    User   @relation(fields: [author_id], references: [id])

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    upvotes        Upvote[]
    comments       Comment[]
    hashTags       PostHashTag[]
    assets         PostAsset[]
    commentUpvotes CommentUpvote[]
    timelines      Timeline[]
    postTopics     PostTopic[]
}

model PostAsset {
    id        String  @id @default(cuid())
    type      String
    url       String
    mime_type String?
    size      Int?

    post_id String
    post    Post   @relation(fields: [post_id], references: [id])

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt
}

model Upvote {
    id String @id @default(cuid())

    post_id String
    post    Post   @relation(fields: [post_id], references: [id])

    user_id String
    user    User   @relation(fields: [user_id], references: [id])

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt
}

model Comment {
    id        String  @id @default(cuid())
    text      String  @db.Text
    parent_id String?

    post_id String
    post    Post   @relation(fields: [post_id], references: [id])

    user_id String
    user    User   @relation(fields: [user_id], references: [id])

    replies Comment[] @relation("Replies")
    parent  Comment?  @relation("Replies", fields: [parent_id], references: [id])

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    upvotes CommentUpvote[]

    @@index([post_id])
}

model CommentUpvote {
    id String @id @default(cuid())

    comment_id String
    comment    Comment @relation(fields: [comment_id], references: [id])

    post_id String
    post    Post   @relation(fields: [post_id], references: [id])

    user_id String
    user    User   @relation(fields: [user_id], references: [id])

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt
}

model HashTag {
    id    String @id @default(cuid())
    count Int    @default(0)
    name  String @unique

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    postHashTags PostHashTag[]
}

model PostHashTag {
    id String @id @default(cuid())

    post_id String
    post    Post   @relation(fields: [post_id], references: [id])

    hash_tag_id String
    hash_tag    HashTag @relation(fields: [hash_tag_id], references: [id])

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt
}

model Follow {
    id String @id @default(cuid())

    // foreign key referencing the id of the user who is following
    follower_id String
    followers   User   @relation("followers", fields: [follower_id], references: [id])

    // foreign key referencing the id of the user who is being followed
    following_id String
    following    User   @relation("following", fields: [following_id], references: [id])

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    @@index([follower_id, following_id], name: "follower_following_index")
}

model Friend {
    id   String     @id @default(cuid())
    type FriendType

    user_id String
    user    User   @relation("user", fields: [user_id], references: [id])

    friend_id String
    friend    User   @relation("friend", fields: [friend_id], references: [id])

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt
}

model Group {
    id                   String      @id @default(cuid())
    name                 String
    about                String
    type                 GroupType
    status               GroupStatus
    join_through_request Boolean     @default(false)

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    members     GroupMember[]
    invitations GroupInvitation[]
    posts       Post[]
}

model GroupMember {
    id         String          @id @default(cuid())
    role       GroupMemberRole @default(MEMBER)
    joined_at  DateTime        @default(now())
    blocked    Boolean         @default(false)
    is_removed Boolean         @default(false)

    user_id String
    user    User   @relation(fields: [user_id], references: [id])

    group_id String
    group    Group  @relation(fields: [group_id], references: [id])

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt
}

enum GroupInvitationStatus {
    PENDING
    ACCEPTED
    REJECTED
}

model GroupInvitation {
    id      String                @id @default(cuid())
    type    GroupInvitationType
    status  GroupInvitationStatus
    sent_at DateTime              @default(now())

    group_id String
    group    Group  @relation(fields: [group_id], references: [id])

    user_id String
    user    User   @relation(fields: [user_id], references: [id])

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt
}

model Notification {
    id         String           @id @default(cuid())
    event_type NotificationType
    event_id   Int
    is_read    Boolean          @default(false)

    user_id String
    user    User   @relation(fields: [user_id], references: [id])

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt
}

model RefreshToken {
    id      String  @id @default(cuid())
    token   String  @unique
    user_id String
    user    User    @relation(fields: [user_id], references: [id])
    revoked Boolean @default(false)

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt
}

model PostTopic {
    post_id  String
    post     Post   @relation(fields: [post_id], references: [id])
    topic_id String
    topic    Topics @relation(fields: [topic_id], references: [id])

    @@unique([post_id, topic_id], name: "post_topic_unique")
}

model Topics {
    id              String  @id @default(cuid())
    name            String  @unique
    is_system_topic Boolean @default(true)

    created_at    DateTime        @default(now())
    updated_at    DateTime        @updatedAt
    userInterests UserInterests[]
    postTopics    PostTopic[]
}

model UserInterests {
    user_id  String
    user     User   @relation(fields: [user_id], references: [id])
    topic_id String
    topic    Topics @relation(fields: [topic_id], references: [id])

    @@unique([user_id, topic_id], name: "user_topic_unique")
}

model UserSimilarity {
    user_id_1  String
    user_id_2  String
    similarity Float

    @@id([user_id_1, user_id_2])
}

model Timeline {
    user_id    String
    post_id    String
    created_at DateTime @default(now())

    user User @relation(fields: [user_id], references: [id])
    post Post @relation(fields: [post_id], references: [id])

    @@unique([user_id, post_id], name: "user_post_unique")
}
