// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider      = "prisma-client-js"
    binaryTargets = ["native"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

enum Gender {
    MALE
    FEMALE
    OTHER
}

enum PostType {
    PUBLIC
    GROUP_ONLY
}

enum PostStatus {
    OPEN
    CLOSED
    ARCHIVED
    INPROGRESS
}

enum FriendType {
    FRIENDS
    PENDING_USER_TO_FRIEND_REQUEST
    PENDING_FRIEND_TO_USER_REQUEST
}

enum GroupType {
    PUBLIC
    PRIVATE
}

enum GroupStatus {
    OPEN
    CLOSED
    INACTIVE
}

enum GroupMemberRole {
    ADMIN
    MODERATOR
    MEMBER
}

enum GroupInvitationType {
    JOIN
    INVITE
}

// Removed NotificationType enum - notification type is now derived from source_type

enum FactorType {
    TOTP
    PHONE
    WEB_AUTHN
}

enum FactorStatus {
    UNVERIFIED
    VERIFIED
}

model User {
    id                    String    @id @default(cuid())
    email                 String    @unique
    user_name             String    @unique @db.VarChar(20)
    password              String
    first_name            String    @db.VarChar(50)
    last_name             String    @db.VarChar(50)
    secret                String    @default(uuid()) // Encrypted secret to sign JWT
    about                 String?   @db.VarChar(256)
    twitter_profile_url   String?
    facebook_profile_url  String?
    instagram_profile_url String?
    github_profile_url    String?
    avatar_url            String?
    cover_image_url       String?
    location              String?   @db.VarChar(100)
    gender                Gender?
    last_login            DateTime?

    is_onboarded               Boolean   @default(false)
    is_email_verify            Boolean   @default(false)
    email_confirmed_at         DateTime?
    email_confirmation_sent_at DateTime?
    banned_until               DateTime?
    vote_bucket                Int       @default(10)
    last_bucket_reset_at       DateTime?

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz

    posts                Post[]
    upvotes              Upvote[]
    comments             Comment[]
    commentUpvotes       CommentUpvote[]
    followers            Follow[]          @relation("followers")
    following            Follow[]          @relation("following")
    friend1              Friend[]          @relation("user")
    friend2              Friend[]          @relation("friend")
    groupMembers         GroupMember[]
    groupInvitations     GroupInvitation[]
    notifications        Notification[]
    createdNotifications Notification[]    @relation("notification_creator")
    factors              Factor[]
    sessions             Session[]
    refreshTokens        RefreshToken[]
    interests            UserInterests[]
    timelines            Timeline[]
    userAggregates       UserAggregates?
}

model Factor {
    id                 String       @id @default(uuid())
    friendly_name      String
    factor_type        FactorType
    status             FactorStatus
    secret             String // Encrypted secret for TOTP
    phone              String? // For phone-based factors
    last_challenged_at DateTime?

    user_id String
    user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz

    sessions   Session[] // Sessions authenticated using this factor
    challenges Challenge[] // Challenges for this factor

    @@index([user_id], name: "user_id_index")
}

model Challenge {
    id       String  @id @default(uuid())
    ip       String
    otp_code String?

    factor_id String
    factor    Factor @relation(fields: [factor_id], references: [id], onDelete: Cascade)

    created_at  DateTime  @default(now()) @db.Timestamptz
    verified_at DateTime?
}

model Session {
    id         String @id @default(uuid())
    aal        String @default("aal1") // Authentication Assurance Level
    ip         String
    user_agent String

    user_id   String
    user      User    @relation(fields: [user_id], references: [id], onDelete: Cascade)
    factor_id String? // Optional if the session requires a factor
    factor    Factor? @relation(fields: [factor_id], references: [id], onDelete: Cascade)

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz

    @@index([user_id], name: "user_session_id_index")
}

model Post {
    id      String     @id @default(cuid())
    title   String     @db.VarChar(50)
    content String     @db.VarChar(300)
    slug    String     @unique @db.VarChar(255)
    type    PostType   @default(PUBLIC)
    status  PostStatus @default(OPEN)

    group_id String?
    group    Group?  @relation(fields: [group_id], references: [id], onDelete: Cascade)

    author_id String
    author    User   @relation(fields: [author_id], references: [id], onDelete: Cascade)

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz

    upvotes        Upvote[]
    comments       Comment[]
    hashTags       PostHashTag[]
    assets         PostAsset[]
    commentUpvotes CommentUpvote[]
    timelines      Timeline[]
    postTopics     PostTopic[]
    postAggregates PostAggregates?

    @@index([author_id], name: "post_author_index")
    @@index([group_id], name: "post_group_index")
}

model PostAsset {
    id        String  @id @default(cuid())
    type      String
    url       String
    mime_type String?
    size      Int?

    post_id String
    post    Post   @relation(fields: [post_id], references: [id], onDelete: Cascade)

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz
}

model Upvote {
    post_id String
    post    Post   @relation(fields: [post_id], references: [id], onDelete: Cascade)

    user_id String
    user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz

    @@unique([post_id, user_id], name: "post_user_unique")
}

model Comment {
    id          String  @id @default(cuid())
    text        String  @db.VarChar(300)
    parent_id   String?
    appreciated Boolean @default(false)

    post_id String
    post    Post   @relation(fields: [post_id], references: [id], onDelete: Cascade)

    user_id String
    user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

    replies Comment[] @relation("Replies")
    parent  Comment?  @relation("Replies", fields: [parent_id], references: [id], onDelete: Cascade)

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz

    upvotes CommentUpvote[]

    @@index([post_id])
    @@index([user_id])
}

model CommentUpvote {
    id String @id @default(cuid())

    comment_id String
    comment    Comment @relation(fields: [comment_id], references: [id], onDelete: Cascade)

    post_id String
    post    Post   @relation(fields: [post_id], references: [id], onDelete: Cascade)

    user_id String
    user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz
}

model HashTag {
    id    String @id @default(cuid())
    count Int    @default(0)
    name  String @unique

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz

    postHashTags PostHashTag[]
}

model PostHashTag {
    id String @id @default(cuid())

    post_id String
    post    Post   @relation(fields: [post_id], references: [id], onDelete: Cascade)

    hash_tag_id String
    hash_tag    HashTag @relation(fields: [hash_tag_id], references: [id], onDelete: Cascade)

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz
}

model Follow {
    id String @id @default(cuid())

    // foreign key referencing the id of the user who is following
    follower_id String
    followers   User   @relation("followers", fields: [follower_id], references: [id], onDelete: Cascade)

    // foreign key referencing the id of the user who is being followed
    following_id String
    following    User   @relation("following", fields: [following_id], references: [id], onDelete: Cascade)

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz

    @@index([follower_id, following_id], name: "follower_following_index")
}

model Friend {
    id   String     @id @default(cuid())
    type FriendType

    user_id String
    user    User   @relation("user", fields: [user_id], references: [id], onDelete: Cascade)

    friend_id String
    friend    User   @relation("friend", fields: [friend_id], references: [id], onDelete: Cascade)

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz
}

model Group {
    id              String      @id @default(cuid())
    name            String      @unique @db.VarChar(21)
    about           String      @db.VarChar(500)
    cover_image_url String?
    logo_url        String?
    type            GroupType
    status          GroupStatus

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz

    members         GroupMember[]
    invitations     GroupInvitation[]
    posts           Post[]
    groupAggregates GroupAggregates?
}

model GroupMember {
    id         String          @id @default(cuid())
    role       GroupMemberRole @default(MEMBER)
    joined_at  DateTime        @default(now())
    blocked    Boolean         @default(false)
    is_removed Boolean         @default(false)

    user_id String
    user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

    group_id String
    group    Group  @relation(fields: [group_id], references: [id], onDelete: Cascade)

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz

    @@unique([user_id, group_id], name: "user_group_unique")
}

enum GroupInvitationStatus {
    PENDING
    ACCEPTED
    REJECTED
}

model GroupInvitation {
    id      String                @id @default(cuid())
    type    GroupInvitationType
    status  GroupInvitationStatus
    sent_at DateTime              @default(now())

    group_id String
    group    Group  @relation(fields: [group_id], references: [id], onDelete: Cascade)

    user_id String
    user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz

    @@unique([user_id, group_id])
}

model Notification {
    id          String @id @default(cuid())
    source_type String
    source_id   String

    user_id String
    user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

    creator_id String?
    creator    User?   @relation("notification_creator", fields: [creator_id], references: [id], onDelete: Cascade)

    read_at    DateTime?
    created_at DateTime  @default(now()) @db.Timestamptz
    updated_at DateTime  @updatedAt @db.Timestamptz

    @@index([user_id, read_at, created_at(sort: Desc)], name: "user_notifications_index")
    @@index([source_type, source_id], name: "notification_source_index")
    @@index([creator_id], name: "notification_creator_index")
}

model RefreshToken {
    id      String  @id @default(cuid())
    token   String  @unique
    user_id String
    user    User    @relation(fields: [user_id], references: [id], onDelete: Cascade)
    revoked Boolean @default(false)

    created_at DateTime @default(now()) @db.Timestamptz
    updated_at DateTime @updatedAt @db.Timestamptz

    @@index([user_id], name: "user_refresh_token_index")
}

model PostTopic {
    post_id  String
    post     Post   @relation(fields: [post_id], references: [id], onDelete: Cascade)
    topic_id String
    topic    Topics @relation(fields: [topic_id], references: [id], onDelete: Cascade)

    @@unique([post_id, topic_id], name: "post_topic_unique")
}

model Topics {
    id              String  @id @default(cuid())
    name            String  @unique @db.VarChar(20)
    is_system_topic Boolean @default(true)

    created_at    DateTime        @default(now()) @db.Timestamptz
    updated_at    DateTime        @updatedAt @db.Timestamptz
    userInterests UserInterests[]
    postTopics    PostTopic[]
}

model UserInterests {
    user_id  String
    user     User   @relation(fields: [user_id], references: [id])
    topic_id String
    topic    Topics @relation(fields: [topic_id], references: [id])

    @@unique([user_id, topic_id], name: "user_topic_unique")
}

model UserSimilarity {
    user_id_1  String
    user_id_2  String
    similarity Float

    @@id([user_id_1, user_id_2])
}

model Timeline {
    user_id    String
    post_id    String
    created_at DateTime @default(now()) @db.Timestamptz

    user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
    post Post @relation(fields: [post_id], references: [id], onDelete: Cascade)

    @@unique([user_id, post_id], name: "user_post_unique")
    @@index([created_at], name: "timeline_created_at_index")
    @@index([user_id], name: "timeline_user_index")
}

model PostAggregates {
    votes    Int    @default(0)
    comments Int    @default(0)
    views    Int    @default(0)
    shares   Int    @default(0)
    post_id  String @id @unique
    post     Post   @relation(fields: [post_id], references: [id], onDelete: Cascade)
}

model UserAggregates {
    total_posts     Int    @default(0)
    total_votes     Int    @default(0)
    total_comments  Int    @default(0)
    total_followers Int    @default(0)
    total_following Int    @default(0)
    total_groups    Int    @default(0)
    user_id         String @id @unique
    user            User   @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model GroupAggregates {
    total_posts    Int    @default(0)
    total_members  Int    @default(0)
    total_comments Int    @default(0)
    total_votes    Int    @default(0)
    group_id       String @id @unique
    group          Group  @relation(fields: [group_id], references: [id], onDelete: Cascade)
}
